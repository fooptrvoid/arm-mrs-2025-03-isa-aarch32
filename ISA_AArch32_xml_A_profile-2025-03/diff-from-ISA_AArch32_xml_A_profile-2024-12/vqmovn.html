<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="insn.css" rel="stylesheet" type="text/css"/><meta content="iform.xsl" name="generator"/><title>VQMOVN, VQMOVUN -- AArch32</title></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">VQMOVN, VQMOVUN</h2>
      <p class="aml">Vector Saturating Move and Narrow copies each element of the operand vector to the corresponding element of the destination vector.</p>
      <p class="aml">The operand is a quadword vector. The elements can be any one of:</p>
      <ul>
        <li>16-bit, 32-bit, or 64-bit signed integers.</li>
        <li>16-bit, 32-bit, or 64-bit unsigned integers.</li>
      </ul>
      <p class="aml">The result is a doubleword vector. The elements are half the length of the operand vector elements. If the operand is unsigned, the results are unsigned. If the operand is signed, the results can be signed or unsigned.</p>
      <p class="aml">If any of the results overflow, they are saturated. The cumulative saturation bit, <a class="armarm-xref" data-linkend="AArch32.fpscr" title="Reference to Armv8 ARM section">FPSCR</a>.QC, is set if saturation occurs. For details see <a class="armarm-xref" data-linkend="BEIHABGJ" title="Reference to Armv8 ARM section">Pseudocode details of saturation</a>.</p>
      <p class="aml">Depending on settings in the <a class="armarm-xref" data-linkend="AArch32.cpacr" title="Reference to Armv8 ARM section">CPACR</a>, <a class="armarm-xref" data-linkend="AArch32.nsacr" title="Reference to Armv8 ARM section">NSACR</a>, and <a class="armarm-xref" data-linkend="AArch32.hcptr" title="Reference to Armv8 ARM section">HCPTR</a> registers, and the Security state and PE mode in which the instruction is executed, an attempt to execute the instruction might be <span class="arm-defined-word">undefined</span>, or trapped to Hyp mode. For more information see <a class="armarm-xref" data-linkend="CIHIDDFF" title="Reference to Armv8 ARM section">Enabling Advanced SIMD and floating-point support</a>.</p>
    <p class="desc">This instruction is used by the pseudo-instructions <a href="vqrshrn_vqmovn.html" title="Vector Saturating Rounding Shift Right">VQRSHRN (zero)</a>, <a href="vqrshrun_vqmovn.html" title="Vector Saturating Rounding Shift Right">VQRSHRUN (zero)</a>, <a href="vqshrn_vqmovn.html" title="Vector Saturating Shift Right">VQSHRN (zero)</a>, and <a href="vqshrun_vqmovn.html" title="Vector Saturating Shift Right">VQSHRUN (zero)</a>.</p>
    <p class="desc">
      It has encodings from the following instruction sets:
       A32 (
      <a href="#iclass_a1">A1</a>
      )
       and 
       T32 (
      <a href="#iclass_t1">T1</a>
      )
      .
    </p>
    <h3 class="classheading"><a id="iclass_a1"/>A1</h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td class="r">1</td><td class="lr">D</td><td class="l">1</td><td class="r">1</td><td class="lr" colspan="2">size</td><td class="l">1</td><td class="r">0</td><td class="lr" colspan="4">Vd</td><td class="lr">0</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr" colspan="2">op</td><td class="lr">M</td><td class="lr">0</td><td class="lr" colspan="4">Vm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">
              Encoding for the Signed result variant
            </h4><a id="VQMOVN_A1"/>
        Applies when
        <span class="bitdiff"> (op == 1x)</span><p class="asm-code">VQMOVN{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#sa_dt" title="Data type for elements of operand (field &quot;op&lt;0>:size&quot;) [S16,S32,S64,U16,U32,U64,UNDEFINED]">&lt;dt></a> <a href="#sa_dd" title="64-bit SIMD&amp;FP destination register (field &quot;D:Vd&quot;)">&lt;Dd></a>, <a href="#sa_qm" title="128-bit SIMD&amp;FP source register (field &quot;M:Vm&quot;)">&lt;Qm></a></p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Unsigned result variant
            </h4><a id="VQMOVUN_A1"/>
        Applies when
        <span class="bitdiff"> (op == 01)</span><p class="asm-code">VQMOVUN{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#sa_dt_1" title="Data type for elements of operand (field &quot;size&quot;) [S16,S32,S64,UNDEFINED]">&lt;dt></a> <a href="#sa_dd" title="64-bit SIMD&amp;FP destination register (field &quot;D:Vd&quot;)">&lt;Dd></a>, <a href="#sa_qm" title="128-bit SIMD&amp;FP source register (field &quot;M:Vm&quot;)">&lt;Qm></a></p></div><h4>Decode for all variants of this encoding</h4><p class="pseudocode">if op == '00' then SEE "VMOVN";
if size == '11' || Vm&lt;0> == '1' then UNDEFINED;
constant src_unsigned = (op == '11');  constant dest_unsigned = (op&lt;0> == '1');
constant integer esize = 8 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);  constant elements = 64 DIV esize;
constant d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  constant m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(M:Vm);</p>
    <h3 class="classheading"><a id="iclass_t1"/>T1</h3><p class="desc"/><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="r">1</td><td class="lr">D</td><td class="l">1</td><td class="r">1</td><td class="lr" colspan="2">size</td><td class="l">1</td><td class="r">0</td><td class="lr" colspan="4">Vd</td><td class="lr">0</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr" colspan="2">op</td><td class="lr">M</td><td class="lr">0</td><td class="lr" colspan="4">Vm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">
              Encoding for the Signed result variant
            </h4><a id="VQMOVN_T1"/>
        Applies when
        <span class="bitdiff"> (op == 1x)</span><p class="asm-code">VQMOVN{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#sa_dt" title="Data type for elements of operand (field &quot;op&lt;0>:size&quot;) [S16,S32,S64,U16,U32,U64,UNDEFINED]">&lt;dt></a> <a href="#sa_dd" title="64-bit SIMD&amp;FP destination register (field &quot;D:Vd&quot;)">&lt;Dd></a>, <a href="#sa_qm" title="128-bit SIMD&amp;FP source register (field &quot;M:Vm&quot;)">&lt;Qm></a></p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Unsigned result variant
            </h4><a id="VQMOVUN_T1"/>
        Applies when
        <span class="bitdiff"> (op == 01)</span><p class="asm-code">VQMOVUN{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#sa_dt_1" title="Data type for elements of operand (field &quot;size&quot;) [S16,S32,S64,UNDEFINED]">&lt;dt></a> <a href="#sa_dd" title="64-bit SIMD&amp;FP destination register (field &quot;D:Vd&quot;)">&lt;Dd></a>, <a href="#sa_qm" title="128-bit SIMD&amp;FP source register (field &quot;M:Vm&quot;)">&lt;Qm></a></p></div><h4>Decode for all variants of this encoding</h4><p class="pseudocode">if op == '00' then SEE "VMOVN";
if size == '11' || Vm&lt;0> == '1' then UNDEFINED;
constant src_unsigned = (op == '11');  constant dest_unsigned = (op&lt;0> == '1');
constant integer esize = 8 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);  constant elements = 64 DIV esize;
constant d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  constant m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(M:Vm);</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;c></td><td><a id="sa_c_1"/>
        
          
          
        
        
          <p class="aml">For encoding A1: see <a class="armarm-xref" data-linkend="Babbefhf" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>. This encoding must be unconditional.</p>
        
      </td></tr><tr><td/><td><a id="sa_c"/>
        
          
          
        
        
          <p class="aml">For encoding T1: see <a class="armarm-xref" data-linkend="Babbefhf" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;q></td><td><a id="sa_q"/>
        
          <p class="aml">See <a class="armarm-xref" data-linkend="Babbefhf" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;dt></td><td><a id="sa_dt"/>
        <p>For the signed result variant: is the data type for the elements of the operand, 
          encoded in
          <q>op&lt;0>:size</q>:
            </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">op&lt;0></th>
                <th class="bitfield">size</th>
                <th class="symbol">&lt;dt></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">0</td>
                <td class="bitfield">00</td>
                <td class="symbol">S16</td>
              </tr>
              <tr>
                <td class="bitfield">0</td>
                <td class="bitfield">01</td>
                <td class="symbol">S32</td>
              </tr>
              <tr>
                <td class="bitfield">0</td>
                <td class="bitfield">10</td>
                <td class="symbol">S64</td>
              </tr>
              <tr>
                <td class="bitfield">0</td>
                <td class="bitfield">11</td>
                <td class="symbol">RESERVED</td>
              </tr>
              <tr>
                <td class="bitfield">1</td>
                <td class="bitfield">00</td>
                <td class="symbol">U16</td>
              </tr>
              <tr>
                <td class="bitfield">1</td>
                <td class="bitfield">01</td>
                <td class="symbol">U32</td>
              </tr>
              <tr>
                <td class="bitfield">1</td>
                <td class="bitfield">10</td>
                <td class="symbol">U64</td>
              </tr>
              <tr>
                <td class="bitfield">1</td>
                <td class="bitfield">11</td>
                <td class="symbol">RESERVED</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr><tr><td/><td><a id="sa_dt_1"/>
        <p>For the unsigned result variant: is the data type for the elements of the operand, 
          encoded in
          <q>size</q>:
            </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">size</th>
                <th class="symbol">&lt;dt></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">00</td>
                <td class="symbol">S16</td>
              </tr>
              <tr>
                <td class="bitfield">01</td>
                <td class="symbol">S32</td>
              </tr>
              <tr>
                <td class="bitfield">10</td>
                <td class="symbol">S64</td>
              </tr>
              <tr>
                <td class="bitfield">11</td>
                <td class="symbol">RESERVED</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Dd></td><td><a id="sa_dd"/>
        
          <p class="aml">Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the "D:Vd" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Qm></td><td><a id="sa_qm"/>
        
          <p class="aml">Is the 128-bit name of the SIMD&amp;FP source register, encoded in the "M:Vm" field as &lt;Qm>*2.</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">if <a href="shared_pseudocode.html#impl-aarch32.ConditionPassed.0" title="function: boolean ConditionPassed()">ConditionPassed</a>() then
    EncodingSpecificOperations();  <a href="shared_pseudocode.html#impl-aarch32.CheckAdvSIMDEnabled.0" title="function: CheckAdvSIMDEnabled()">CheckAdvSIMDEnabled</a>();
    for e = 0 to elements-1
        constant operand = <a href="shared_pseudocode.html#impl-shared.Int.2" title="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[<a href="shared_pseudocode.html#impl-aarch32.Qin.read.1" title="accessor: bits(128) Qin[integer n]">Qin</a>[m>>1],e,2*esize], src_unsigned);
        boolean sat;
<ins>        bits(esize) res;
        (res, sat) =</ins><del>        (</del> <a href="shared_pseudocode.html#impl-shared.SatQ.3" title="function: (bits(N), boolean) SatQ(integer i, integer N, boolean unsigned)"><ins>SatQ</ins></a><ins>(operand, esize, dest_unsigned);
        </ins><a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[<a href="shared_pseudocode.html#impl-aarch32.D.write.1" title="accessor: D[integer n] = bits(64) value">D</a><del>[d],e,esize], sat) = </del><a href="shared_pseudocode.html#impl-shared.SatQ.3" title="function: (bits(N), boolean) SatQ(integer i, integer N, boolean unsigned)"><del>SatQ</del></a><ins>[d],e,esize] = res;
</ins><del>(operand, esize, dest_unsigned);
</del>        if sat then FPSCR.QC = '1';</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v01_32, pseudocode <ins>v2025-03_rel</ins><del>v2024-12_rel_diff_tag2</del>
      ; Build timestamp: <ins>2025-03-21T16</ins><del>2025-03-18T12</del>:<ins>47</ins><del>24</del>
    </p><p class="copyconf">
      Copyright © <ins>2010-2025</ins><del>2010-2024</del> Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>
