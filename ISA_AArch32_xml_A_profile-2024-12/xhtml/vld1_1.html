<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>VLD1 (single element to one lane) -- AArch32</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">VLD1 (single element to one lane)</h2>
      <p class="aml">Load single 1-element structure to one lane of one register loads one element from memory into one element of a register. Elements of the register that are not loaded are unchanged. For details of the addressing mode, see <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="Cjaefebe">Advanced SIMD addressing mode</a>.</p>
      <p class="aml">Depending on settings in the <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="AArch32.cpacr">CPACR</a>, <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="AArch32.nsacr">NSACR</a>, and <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="AArch32.hcptr">HCPTR</a> registers, and the Security state and PE mode in which the instruction is executed, an attempt to execute the instruction might be <span class="arm-defined-word">undefined</span>, or trapped to Hyp mode. For more information, see <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="CIHIDDFF">Enabling Advanced SIMD and floating-point support</a>.</p>
    
    <p class="desc">
      It has encodings from the following instruction sets:
       A32 (
      <a href="#iclass_a1">A1</a>
      , 
      <a href="#iclass_a2">A2</a>
       and 
      <a href="#iclass_a3">A3</a>
      )
       and 
       T32 (
      <a href="#iclass_t1">T1</a>
      , 
      <a href="#iclass_t2">T2</a>
       and 
      <a href="#iclass_t3">T3</a>
      )
      .
    </p>
    <h3 class="classheading"><a id="iclass_a1"/>A1</h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">D</td><td class="lr">1</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">0</td><td class="r">0</td><td class="l">0</td><td class="r">0</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">
              Encoding for the Offset variant
            </h4><a id="VLD1_1_A1_nowb"/>
        Applies when
        <span class="bitdiff"> (Rm == 1111)</span><p class="asm-code">VLD1{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_A1_posti"/>
        Applies when
        <span class="bitdiff"> (Rm == 1101)</span><p class="asm-code">VLD1{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_A1_postr"/>
        Applies when
        <span class="bitdiff"> (Rm != 11x1)</span><p class="asm-code">VLD1{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><h4>Decode for all variants of this encoding</h4><p class="pseudocode">if size == '11' then SEE "VLD1 (single element to all lanes)";
if index_align&lt;0&gt; != '0' then UNDEFINED;
constant ebytes = 1;  constant index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3:1&gt;);  constant alignment = 1;
constant d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  constant n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  constant m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
constant wback = (m != 15);  constant register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 then UNPREDICTABLE;</p>
    <h3 class="classheading"><a id="iclass_a2"/>A2</h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">D</td><td class="lr">1</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">0</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">
              Encoding for the Offset variant
            </h4><a id="VLD1_1_A2_nowb"/>
        Applies when
        <span class="bitdiff"> (Rm == 1111)</span><p class="asm-code">VLD1{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_A2_posti"/>
        Applies when
        <span class="bitdiff"> (Rm == 1101)</span><p class="asm-code">VLD1{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_A2_postr"/>
        Applies when
        <span class="bitdiff"> (Rm != 11x1)</span><p class="asm-code">VLD1{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><h4>Decode for all variants of this encoding</h4><p class="pseudocode">if size == '11' then SEE "VLD1 (single element to all lanes)";
if index_align&lt;1&gt; != '0' then UNDEFINED;
constant ebytes = 2;  constant index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3:2&gt;);
constant alignment = if index_align&lt;0&gt; == '0' then 1 else 2;
constant d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  constant n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  constant m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
constant wback = (m != 15);  constant register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 then UNPREDICTABLE;</p>
    <h3 class="classheading"><a id="iclass_a3"/>A3</h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">D</td><td class="lr">1</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td class="r">0</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">
              Encoding for the Offset variant
            </h4><a id="VLD1_1_A3_nowb"/>
        Applies when
        <span class="bitdiff"> (Rm == 1111)</span><p class="asm-code">VLD1{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_A3_posti"/>
        Applies when
        <span class="bitdiff"> (Rm == 1101)</span><p class="asm-code">VLD1{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_A3_postr"/>
        Applies when
        <span class="bitdiff"> (Rm != 11x1)</span><p class="asm-code">VLD1{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><h4>Decode for all variants of this encoding</h4><p class="pseudocode">if size == '11' then SEE "VLD1 (single element to all lanes)";
if index_align&lt;2&gt; != '0' then UNDEFINED;
if index_align&lt;1:0&gt; != '00' &amp;&amp; index_align&lt;1:0&gt; != '11' then UNDEFINED;
constant ebytes = 4;  constant index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3&gt;);
constant alignment = if index_align&lt;1:0&gt; == '00' then 1 else 4;
constant d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  constant n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  constant m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
constant wback = (m != 15);  constant register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 then UNPREDICTABLE;</p>
    <h3 class="classheading"><a id="iclass_t1"/>T1</h3><p class="desc"/><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">1</td><td class="lr">D</td><td class="lr">1</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">0</td><td class="r">0</td><td class="l">0</td><td class="r">0</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">
              Encoding for the Offset variant
            </h4><a id="VLD1_1_T1_nowb"/>
        Applies when
        <span class="bitdiff"> (Rm == 1111)</span><p class="asm-code">VLD1{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_T1_posti"/>
        Applies when
        <span class="bitdiff"> (Rm == 1101)</span><p class="asm-code">VLD1{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_T1_postr"/>
        Applies when
        <span class="bitdiff"> (Rm != 11x1)</span><p class="asm-code">VLD1{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><h4>Decode for all variants of this encoding</h4><p class="pseudocode">if size == '11' then SEE "VLD1 (single element to all lanes)";
if index_align&lt;0&gt; != '0' then UNDEFINED;
constant ebytes = 1;  constant index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3:1&gt;);  constant alignment = 1;
constant d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  constant n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  constant m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
constant wback = (m != 15);  constant register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 then UNPREDICTABLE;</p>
    <h3 class="classheading"><a id="iclass_t2"/>T2</h3><p class="desc"/><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">1</td><td class="lr">D</td><td class="lr">1</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">0</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">
              Encoding for the Offset variant
            </h4><a id="VLD1_1_T2_nowb"/>
        Applies when
        <span class="bitdiff"> (Rm == 1111)</span><p class="asm-code">VLD1{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_T2_posti"/>
        Applies when
        <span class="bitdiff"> (Rm == 1101)</span><p class="asm-code">VLD1{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_T2_postr"/>
        Applies when
        <span class="bitdiff"> (Rm != 11x1)</span><p class="asm-code">VLD1{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><h4>Decode for all variants of this encoding</h4><p class="pseudocode">if size == '11' then SEE "VLD1 (single element to all lanes)";
if index_align&lt;1&gt; != '0' then UNDEFINED;
constant ebytes = 2;  constant index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3:2&gt;);
constant alignment = if index_align&lt;0&gt; == '0' then 1 else 2;
constant d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  constant n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  constant m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
constant wback = (m != 15);  constant register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 then UNPREDICTABLE;</p>
    <h3 class="classheading"><a id="iclass_t3"/>T3</h3><p class="desc"/><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">1</td><td class="lr">D</td><td class="lr">1</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td class="r">0</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">
              Encoding for the Offset variant
            </h4><a id="VLD1_1_T3_nowb"/>
        Applies when
        <span class="bitdiff"> (Rm == 1111)</span><p class="asm-code">VLD1{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_T3_posti"/>
        Applies when
        <span class="bitdiff"> (Rm == 1101)</span><p class="asm-code">VLD1{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Post-indexed variant
            </h4><a id="VLD1_1_T3_postr"/>
        Applies when
        <span class="bitdiff"> (Rm != 11x1)</span><p class="asm-code">VLD1{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the single 64-bit SIMD&amp;FP register holding element (field &quot;D:Vd&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="When {syntax{&lt;size&gt;}} == 8, {syntax{&lt;align&gt;}} must be omitted, otherwise it is the optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><h4>Decode for all variants of this encoding</h4><p class="pseudocode">if size == '11' then SEE "VLD1 (single element to all lanes)";
if index_align&lt;2&gt; != '0' then UNDEFINED;
if index_align&lt;1:0&gt; != '00' &amp;&amp; index_align&lt;1:0&gt; != '11' then UNDEFINED;
constant ebytes = 4;  constant index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3&gt;);
constant alignment = if index_align&lt;1:0&gt; == '00' then 1 else 4;
constant d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  constant n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  constant m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
constant wback = (m != 15);  constant register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 then UNPREDICTABLE;</p>
  <div class="encoding-notes">
      <p class="aml">For more information about the <span class="arm-defined-word">constrained unpredictable</span> behavior of this instruction, see <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="CJAEGDJC">Architectural Constraints on UNPREDICTABLE behaviors</a>.</p>
    </div><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;c&gt;</td><td><a id="sa_c_1"/>
        
          
        
        
          <p class="aml">For encoding A1, A2 and A3: see <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="Babbefhf">Standard assembler syntax fields</a>. This encoding must be unconditional.</p>
        
      </td></tr><tr><td/><td><a id="sa_c"/>
        
          
        
        
          <p class="aml">For encoding T1, T2 and T3: see <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="Babbefhf">Standard assembler syntax fields</a>.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;q&gt;</td><td><a id="sa_q"/>
        
          <p class="aml">See <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="Babbefhf">Standard assembler syntax fields</a>.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;size&gt;</td><td><a id="sa_size"/>
        <p>Is the data size, 
          encoded in
          <q>size</q>:
            </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">size</th>
                <th class="symbol">&lt;size&gt;</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">00</td>
                <td class="symbol">8</td>
              </tr>
              <tr>
                <td class="bitfield">01</td>
                <td class="symbol">16</td>
              </tr>
              <tr>
                <td class="bitfield">10</td>
                <td class="symbol">32</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;list&gt;</td><td><a id="sa_list"/>
        
          <p class="aml">Is a list containing the single 64-bit name of the SIMD&amp;FP register holding the element.</p>
          <p class="aml">The list must be { &lt;Dd&gt;[&lt;index&gt;] }.</p>
          <p class="aml">The register &lt;Dd&gt; is encoded in the "D:Vd" field.</p>
          <p class="aml">The permitted values and encoding of &lt;index&gt; depend on &lt;size&gt;:</p>
          <dl>
            <dt>&lt;size&gt; == 8</dt><dd>&lt;index&gt; is in the range 0 to 7, encoded in the "index_align&lt;3:1&gt;" field.</dd>
            <dt>&lt;size&gt; == 16</dt><dd>&lt;index&gt; is in the range 0 to 3, encoded in the "index_align&lt;3:2&gt;" field.</dd>
            <dt>&lt;size&gt; == 32</dt><dd>&lt;index&gt; is 0 or 1, encoded in the "index_align&lt;3&gt;" field.</dd>
          </dl>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Rn&gt;</td><td><a id="sa_rn"/>
        
          <p class="aml">Is the general-purpose base register, encoded in the "Rn" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;align&gt;</td><td><a id="sa_align"/>
        
          <p class="aml">When &lt;size&gt; == 8, &lt;align&gt; must be omitted, otherwise it is the optional alignment.</p>
          <p class="aml">Whenever &lt;align&gt; is omitted, the standard alignment is used, see <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="Chdijihg">Unaligned data access</a>, and the encoding depends on &lt;size&gt;:</p>
          <dl>
            <dt>&lt;size&gt; == 8</dt><dd>Encoded in the "index_align&lt;0&gt;" field as 0.</dd>
            <dt>&lt;size&gt; == 16</dt><dd>Encoded in the "index_align&lt;1:0&gt;" field as 0b00.</dd>
            <dt>&lt;size&gt; == 32</dt><dd>Encoded in the "index_align&lt;2:0&gt;" field as 0b000.</dd>
          </dl>
          <p class="aml">Whenever &lt;align&gt; is present, the permitted values and encoding depend on &lt;size&gt;:</p>
          <dl>
            <dt>&lt;size&gt; == 16</dt><dd>&lt;align&gt; is 16, meaning 16-bit alignment, encoded in the "index_align&lt;1:0&gt;" field as 0b01.</dd>
            <dt>&lt;size&gt; == 32</dt><dd>&lt;align&gt; is 32, meaning 32-bit alignment, encoded in the "index_align&lt;2:0&gt;" field as 0b011.</dd>
          </dl>
          <p class="aml">: is the preferred separator before the &lt;align&gt; value, but the alignment can be specified as @&lt;align&gt;, see <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="Cjaefebe">Advanced SIMD addressing mode</a>.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Rm&gt;</td><td><a id="sa_rm"/>
        
          <p class="aml">Is the general-purpose index register containing an offset applied after the access, encoded in the "Rm" field.</p>
        
      </td></tr></table></div><div class="syntax-notes">
      <p class="aml">For more information about the variants of this instruction, see <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="Cjaefebe">Advanced SIMD addressing mode</a>.</p>
    </div>
    <div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">if <a href="shared_pseudocode.html#impl-aarch32.ConditionPassed.0" title="function: boolean ConditionPassed()">ConditionPassed</a>() then
    EncodingSpecificOperations();
    <a href="shared_pseudocode.html#impl-aarch32.CheckAdvSIMDEnabled.0" title="function: CheckAdvSIMDEnabled()">CheckAdvSIMDEnabled</a>();

    constant address = <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n];

    constant boolean nontemporal = FALSE;
    constant boolean privileged  = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    constant boolean tagchecked  = FALSE;
    constant <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean withstatus, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, boolean stzgm, boolean ispair, boolean highestaddressfirst, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescASIMD.4" title="function: AccessDescriptor CreateAccDescASIMD(MemOp memop, boolean nontemporal, boolean tagchecked, boolean privileged)">CreateAccDescASIMD</a>(<a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>, nontemporal,
                                        tagchecked, privileged);
    if !<a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(bits(N) x, integer y)">IsAligned</a>(address, alignment) then
        constant <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor accessdesc, bits(64) vaddress, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean s1tagnotdata, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, boolean hdbssf, WatchpointInfo watchptinfo, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.AlignmentFault.2" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc, bits(64) vaddress)">AlignmentFault</a>(accdesc, <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64));
        <a href="shared_pseudocode.html#AArch32.Abort.1" title="function: AArch32.Abort(FaultRecord fault)">AArch32.Abort</a>(fault);

    <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[<a href="shared_pseudocode.html#impl-aarch32.D.write.1" title="accessor: D[integer n] = bits(64) value">D</a>[d],index,8*ebytes] = <a href="shared_pseudocode.html#impl-aarch32.MemU.read.2" title="accessor: bits(8*size) MemU[bits(32) address, integer size]">MemU</a>[address,ebytes];
    if wback then
        if register_index then
            <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[n] = <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n] + <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[m];
        else
            <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[n] = <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n] + ebytes;</p>
    </div>
  <h3>Operational information</h3>
    <p class="aml">If CPSR.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.</p>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v01_32, pseudocode v2024-12_rel_diff_tag2
      ; Build timestamp: 2025-03-18T12:24
    </p><p class="copyconf">
      Copyright Â© 2010-2024 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
